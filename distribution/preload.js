(()=>{"use strict";var e,t,r={},i={};function o(e){var t=i[e];if(void 0!==t)return t.exports;var n=i[e]={exports:{}};return r[e](n,n.exports,o),n.exports}t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,o.t=function(r,i){if(1&i&&(r=this(r)),8&i)return r;if("object"==typeof r&&r){if(4&i&&r.__esModule)return r;if(16&i&&"function"==typeof r.then)return r}var n=Object.create(null);o.r(n);var s={};e=e||[null,t({}),t([]),t(t)];for(var a=2&i&&r;"object"==typeof a&&!~e.indexOf(a);a=t(a))Object.getOwnPropertyNames(a).forEach((e=>s[e]=()=>r[e]));return s.default=()=>r,o.d(n,s),n},o.d=(e,t)=>{for(var r in t)o.o(t,r)&&!o.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},o.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),o.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};const n=require("node:crypto");var s=o.t(n,2);const a=(()=>{if("object"==typeof globalThis)return globalThis;Object.defineProperty(Object.prototype,"__GLOBALTHIS__",{get(){return this},configurable:!0});try{if("undefined"!=typeof __GLOBALTHIS__)return __GLOBALTHIS__}finally{delete Object.prototype.__GLOBALTHIS__}return"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:void 0})(),l={SHA1:"SHA-1",SHA224:"SHA-224",SHA256:"SHA-256",SHA384:"SHA-384",SHA512:"SHA-512","SHA3-224":"SHA3-224","SHA3-256":"SHA3-256","SHA3-384":"SHA3-384","SHA3-512":"SHA3-512"},u="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",d=e=>{let t=e.length;for(;"="===e[t-1];)--t;const r=(t<e.length?e.substring(0,t):e).toUpperCase(),i=new ArrayBuffer(5*r.length/8|0),o=new Uint8Array(i);let n=0,s=0,a=0;for(let e=0;e<r.length;e++){const t=u.indexOf(r[e]);if(-1===t)throw new TypeError(`Invalid character found: ${r[e]}`);s=s<<5|t,n+=5,n>=8&&(n-=8,o[a++]=s>>>n)}return i},f=e=>{const t=new Uint8Array(e);let r=0,i=0,o="";for(let e=0;e<t.length;e++)for(i=i<<8|t[e],r+=8;r>=5;)o+=u[i>>>r-5&31],r-=5;return r>0&&(o+=u[i<<5-r&31]),o},h=e=>{const t=new ArrayBuffer(e.length/2),r=new Uint8Array(t);for(let t=0;t<e.length;t+=2)r[t/2]=parseInt(e.substring(t,t+2),16);return t},c=e=>{const t=new Uint8Array(e);let r="";for(let e=0;e<t.length;e++){const i=t[e].toString(16);1===i.length&&(r+="0"),r+=i}return r.toUpperCase()},g=e=>{const t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=255&e.charCodeAt(t);return t},p=e=>{const t=new Uint8Array(e);let r="";for(let e=0;e<t.length;e++)r+=String.fromCharCode(t[e]);return r},m=a.TextEncoder?new a.TextEncoder("utf-8"):null,w=a.TextDecoder?new a.TextDecoder("utf-8"):null,b=e=>{if(!m)throw new Error("Encoding API not available");return m.encode(e).buffer},y=e=>{if(!w)throw new Error("Encoding API not available");return w.decode(e)};class A{constructor(){let{buffer:e,size:t=20}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.buffer=void 0===e?(e=>{if(s?.randomBytes)return n.randomBytes(e).buffer;if(!a.crypto?.getRandomValues)throw new Error("Cryptography API not available");return a.crypto.getRandomValues(new Uint8Array(e)).buffer})(t):e}static fromLatin1(e){return new A({buffer:g(e)})}static fromUTF8(e){return new A({buffer:b(e)})}static fromBase32(e){return new A({buffer:d(e)})}static fromHex(e){return new A({buffer:h(e)})}get latin1(){return Object.defineProperty(this,"latin1",{enumerable:!0,value:p(this.buffer)}),this.latin1}get utf8(){return Object.defineProperty(this,"utf8",{enumerable:!0,value:y(this.buffer)}),this.utf8}get base32(){return Object.defineProperty(this,"base32",{enumerable:!0,value:f(this.buffer)}),this.base32}get hex(){return Object.defineProperty(this,"hex",{enumerable:!0,value:c(this.buffer)}),this.hex}}const v=(e,t)=>{if(s?.timingSafeEqual)return n.timingSafeEqual(a.Buffer.from(e),a.Buffer.from(t));{if(e.length!==t.length)throw new TypeError("Input strings must have the same length");let r=-1,i=0;for(;++r<e.length;)i|=e.charCodeAt(r)^t.charCodeAt(r);return 0===i}};class S{static get defaults(){return{issuer:"",label:"OTPAuth",algorithm:"SHA1",digits:6,counter:0,window:1}}constructor(){let{issuer:e=S.defaults.issuer,label:t=S.defaults.label,secret:r=new A,algorithm:i=S.defaults.algorithm,digits:o=S.defaults.digits,counter:n=S.defaults.counter}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.issuer=e,this.label=t,this.secret="string"==typeof r?A.fromBase32(r):r,this.algorithm=i.toUpperCase(),this.digits=o,this.counter=n}static generate(e){let{secret:t,algorithm:r=S.defaults.algorithm,digits:i=S.defaults.digits,counter:o=S.defaults.counter}=e;const u=new Uint8Array(((e,t,r)=>{if(s?.createHmac){const i=n.createHmac(e,a.Buffer.from(t));return i.update(a.Buffer.from(r)),i.digest().buffer}{const i=l[e.toUpperCase()];if(void 0===i)throw new TypeError("Unknown hash function");const o=new undefined(i,"ARRAYBUFFER");return o.setHMACKey(t,"ARRAYBUFFER"),o.update(r),o.getHMAC("ARRAYBUFFER")}})(r,t.buffer,(e=>{const t=new ArrayBuffer(8),r=new Uint8Array(t);let i=e;for(let e=7;e>=0&&0!==i;e--)r[e]=255&i,i-=r[e],i/=256;return t})(o))),d=15&u[u.byteLength-1];return(((127&u[d])<<24|(255&u[d+1])<<16|(255&u[d+2])<<8|255&u[d+3])%10**i).toString().padStart(i,"0")}generate(){let{counter:e=this.counter++}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return S.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:e})}static validate(e){let{token:t,secret:r,algorithm:i,digits:o,counter:n=S.defaults.counter,window:s=S.defaults.window}=e;if(t.length!==o)return null;let a=null;for(let e=n-s;e<=n+s;++e){const s=S.generate({secret:r,algorithm:i,digits:o,counter:e});v(t,s)&&(a=e-n)}return a}validate(e){let{token:t,counter:r=this.counter,window:i}=e;return S.validate({token:t,secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:r,window:i})}toString(){const e=encodeURIComponent;return"otpauth://hotp/"+(this.issuer.length>0?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`)+`secret=${e(this.secret.base32)}&`+`algorithm=${e(this.algorithm)}&`+`digits=${e(this.digits)}&`+`counter=${e(this.counter)}`}}class O{static get defaults(){return{issuer:"",label:"OTPAuth",algorithm:"SHA1",digits:6,period:30,window:1}}constructor(){let{issuer:e=O.defaults.issuer,label:t=O.defaults.label,secret:r=new A,algorithm:i=O.defaults.algorithm,digits:o=O.defaults.digits,period:n=O.defaults.period}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.issuer=e,this.label=t,this.secret="string"==typeof r?A.fromBase32(r):r,this.algorithm=i.toUpperCase(),this.digits=o,this.period=n}static generate(e){let{secret:t,algorithm:r,digits:i,period:o=O.defaults.period,timestamp:n=Date.now()}=e;return S.generate({secret:t,algorithm:r,digits:i,counter:Math.floor(n/1e3/o)})}generate(){let{timestamp:e=Date.now()}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return O.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:e})}static validate(e){let{token:t,secret:r,algorithm:i,digits:o,period:n=O.defaults.period,timestamp:s=Date.now(),window:a}=e;return S.validate({token:t,secret:r,algorithm:i,digits:o,counter:Math.floor(s/1e3/n),window:a})}validate(e){let{token:t,timestamp:r,window:i}=e;return O.validate({token:t,secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:r,window:i})}toString(){const e=encodeURIComponent;return"otpauth://totp/"+(this.issuer.length>0?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`)+`secret=${e(this.secret.base32)}&`+`algorithm=${e(this.algorithm)}&`+`digits=${e(this.digits)}&`+`period=${e(this.period)}`}}const H=/^otpauth:\/\/([ht]otp)\/(.+)\?([A-Z0-9.~_-]+=[^?&]*(?:&[A-Z0-9.~_-]+=[^?&]*)*)$/i,T=/^[2-7A-Z]+=*$/i,E=/^SHA(?:1|224|256|384|512|3-224|3-256|3-384|3-512)$/i,I=/^[+-]?\d+$/,U=/^\+?[1-9]\d*$/;class _{static parse(e){let t;try{t=e.match(H)}catch(e){}if(!Array.isArray(t))throw new URIError("Invalid URI format");const r=t[1].toLowerCase(),i=t[2].split(/(?::|%3A) *(.+)/i,2).map(decodeURIComponent),o=t[3].split("&").reduce(((e,t)=>{const r=t.split(/=(.*)/,2).map(decodeURIComponent),i=r[0].toLowerCase(),o=r[1],n=e;return n[i]=o,n}),{});let n;const s={};if("hotp"===r){if(n=S,void 0===o.counter||!I.test(o.counter))throw new TypeError("Missing or invalid 'counter' parameter");s.counter=parseInt(o.counter,10)}else{if("totp"!==r)throw new TypeError("Unknown OTP type");if(n=O,void 0!==o.period){if(!U.test(o.period))throw new TypeError("Invalid 'period' parameter");s.period=parseInt(o.period,10)}}if(2===i.length?(s.label=i[1],s.issuer=i[0]):(s.label=i[0],void 0!==o.issuer&&(s.issuer=o.issuer)),void 0===o.secret||!T.test(o.secret))throw new TypeError("Missing or invalid 'secret' parameter");if(s.secret=o.secret,void 0!==o.algorithm){if(!E.test(o.algorithm))throw new TypeError("Invalid 'algorithm' parameter");s.algorithm=o.algorithm}if(void 0!==o.digits){if(!U.test(o.digits))throw new TypeError("Invalid 'digits' parameter");s.digits=parseInt(o.digits,10)}return new n(s)}static stringify(e){if(e instanceof S||e instanceof O)return e.toString();throw new TypeError("Invalid 'HOTP/TOTP' object")}}function C(){const e=_.parse("otpauth://totp/wanghe06000@KAYAKWISE.COM:wanghe06000_OTP?digits=6&secret=V6YZWJLHVDVV3VRYBOUBDCZRQD4CM2YT3TMEKQ33XYMJO4JS3ICT4ZG3&period=60&algorithm=SHA512&issuer=wanghe06000%40KAYAKWISE.COM"),t=e.generate();return{title:e.issuer,description:t,icon:"logo.png"}}window.exports={otp_list:{mode:"list",args:{enter:(e,t)=>{t([C()])}}}}})();